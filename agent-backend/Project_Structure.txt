trip-planner-ai-backend/
├── app/
│   ├── api/                            # FastAPI route definitions explicitly
│   │   ├── endpoints/
│   │   │   └── agent.py                # Chat interaction endpoint explicitly
│   │   └── api_v1.py                   # Aggregates v1 API explicitly
│   │
│   ├── core/                           # Core logic/config/security explicitly
│   │   ├── config.py                   # Constants, RotatingGemini class explicitly here
│   │   └── security.py                 # Authentication/security explicitly (future)
│   │
│   ├── models/                         # Request/response schemas explicitly defined
│   │   └── schemas.py
│   │
│   ├── services/                       # External API integrations explicitly separated
│   │   ├── geoapify.py                 # Geoapify API calls explicitly
│   │   ├── calculator_api.py           # Budget calculator API explicitly
│   │   └── location_storage.py         # Database storage explicitly (MongoDB interaction)
│   │
│   ├── agent/                          # LangGraph Agent logic explicitly defined
│   │   ├── graph.py                    # Agent pipeline (nodes explicitly defined here)
│   │   ├── prompts.py                  # Structured prompts explicitly here
│   │   ├── output_parser.py            # Parses LLM outputs into structured JSON explicitly
│   │   └── response_verifier.py        # Verification logic explicitly
│   │
│   ├── utils/                          # Helper utilities explicitly defined
│   │   ├── helpers.py                  # Common utility functions explicitly
│   │   └── rate_limit.py               # API rate-limit handler explicitly (optional)
│   │
│   └── main.py                         # FastAPI application entry point explicitly
│
├── tests/                              # Explicit test cases
│   ├── test_agent.py
│   └── test_routes.py
│
├── .env                                # Environment variables (keys explicitly defined here)
├── requirements.txt                    # Python dependencies explicitly listed
└── Dockerfile                          # Explicit containerization (recommended)

Agent's State:
user_query: ""
requirements_by_user: [""]
extracted_location:
extracted_routes_metadata:
extracted_expense_metadata:
expense_table:
ui_commands(also include the order):
final_text_response:""


requirement_by_user: Name of the nodes which we need to call out of location : [
    ""
]


Agent's flow
Node 1: Find out which application API/nodes need to be called based on the user query and available nodes:
like ["extract_location", "routes_path_metadata", "expense_finder_web_search"]

Node 2: Data Extractor Node:
Select if need to call the Agent state updated by the Node 1, This also validates basic structure of the metadata from API key response. Or just add it as it is for the final response. 

Node 3:
Verify the data returned from node 2 is logical or not as per the available state, and if
not: then re query the node 2 by updating the state like updating the user_requirement agent state and respective extracted data.

yes: If required then go ahead for optimal route creation based on the user query for route creation considering user specific directives. If nothing specified by the user consider time and possible money expenses as the criteria try to choose the route where first preference is minimizing time and then preference is minimizing expenses. Also consider the basic attiqutes like avoid late night flight pick ups unless user specified. If user is asking for tourist spot consider also the opening time of the respective tourist places. I might need to have a web search functionality here so that agent can do web search as and when required. Consider expense calculation related web search here itself. So basically I can say here you will do web search for:
1. Verification of routes(if required)
2. Tourist Placees's opening and closing time(if required)
3. Finding expense for different things(if required)


Then craft the final response. After crafting final response move to next node

Node verifier:
1. Verifies the final response wrt to user query
2. Verifies for hallucination
3. Save the location marker in mongoDB
4. Finaly go for parsing the LLM response

If find any issue like not able to fully satisfies the user query, or hallucination go to node 3 again 
Max fallback


I am not sure what all I can have here as node and what as a function calling LLM directly. Tell me with reasons and why you want to so in the Agent architecture how it going to help make the Agent to process fast and extract relevant things? Also I am not very much sure of the Agent State I have made is correct. I think it is wrong.